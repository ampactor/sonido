# DSP Fundamentals in Sonido

This document explains the digital signal processing theory behind Sonido's implementations. Each section connects mathematical concepts to specific source code, showing how textbook DSP translates into production Rust.

## Table of Contents

- [Sampling Theory and Aliasing](#sampling-theory-and-aliasing)
- [Anti-Aliased Oscillators: PolyBLEP](#anti-aliased-oscillators-polyblep)
- [Oversampling for Nonlinear Processing](#oversampling-for-nonlinear-processing)
- [Digital Filters](#digital-filters)
  - [Biquad (Second-Order IIR)](#biquad-second-order-iir)
  - [State Variable Filter (SVF)](#state-variable-filter-svf)
  - [One-Pole Filters](#one-pole-filters)
- [Delay Lines and Interpolation](#delay-lines-and-interpolation)
- [Reverb: Freeverb Topology](#reverb-freeverb-topology)
- [Parameter Smoothing](#parameter-smoothing)
- [Waveshaping and Distortion](#waveshaping-and-distortion)
- [Dynamics Processing](#dynamics-processing)
- [Modulation Effects](#modulation-effects)
- [Tempo Synchronization](#tempo-synchronization)
- [Denormal Protection](#denormal-protection)
- [Numerical Considerations](#numerical-considerations)

---

## Sampling Theory and Aliasing

The Nyquist-Shannon theorem states that a continuous signal can be perfectly reconstructed from discrete samples only if the signal contains no frequency components above half the sample rate (the Nyquist frequency). At 48 kHz, this limit is 24 kHz.

**Aliasing** occurs when frequencies above Nyquist are present in a signal. Instead of being rejected, they fold back into the audible range as inharmonic artifacts. This is especially problematic for:

1. **Oscillators** generating non-sinusoidal waveforms (saw, square, pulse) whose Fourier series contain infinite harmonics
2. **Nonlinear processing** (distortion, waveshaping) that creates new harmonics from the input signal

Sonido addresses both cases: PolyBLEP for oscillators and oversampling for nonlinear effects.

---

## Anti-Aliased Oscillators: PolyBLEP

**Source:** `crates/sonido-synth/src/oscillator.rs`

### The Problem with Naive Waveforms

A naive digital sawtooth wave is defined as:

```
saw(t) = 2t - 1,  t in [0, 1)
```

This has an instantaneous discontinuity at `t = 0` where the value jumps from +1 to -1. In the frequency domain, this discontinuity produces harmonics at every integer multiple of the fundamental frequency, extending to infinity. Since a digital system cannot represent frequencies above Nyquist, these harmonics alias back, producing audible artifacts especially at higher pitches.

### The PolyBLEP Solution

PolyBLEP (Polynomial Band-Limited Step) applies a polynomial correction in a small region around each discontinuity. Rather than computing a true band-limited waveform (expensive), PolyBLEP approximates one by smoothing only the transition region.

The correction function in Sonido (`oscillator.rs:183-195`):

```rust
fn poly_blep(t: f32, dt: f32) -> f32 {
    if t < dt {
        // Just past discontinuity
        let t = t / dt;
        2.0 * t - t * t - 1.0
    } else if t > 1.0 - dt {
        // Just before discontinuity
        let t = (t - 1.0) / dt;
        t * t + 2.0 * t + 1.0
    } else {
        0.0
    }
}
```

The parameter `dt` is the phase increment per sample (`frequency / sample_rate`). This defines the width of the correction window. The key insight: the correction window scales with frequency. At higher frequencies (larger `dt`), the correction spans more of the waveform, providing stronger anti-aliasing exactly where it is needed most.

### Waveform Generation

**Sawtooth** (`oscillator.rs:153-157`): The naive sawtooth minus the PolyBLEP correction at phase 0:

```rust
let naive = 2.0 * phase - 1.0;
naive - poly_blep(phase, self.phase_inc)
```

**Square/Pulse** (`oscillator.rs:169-180`): Two PolyBLEP corrections, one at the rising edge (phase 0) and one at the falling edge (phase = duty cycle):

```rust
let naive = if phase < duty { 1.0 } else { -1.0 };
let blep1 = poly_blep(phase, self.phase_inc);
let blep2 = poly_blep(rem_euclid_f32(phase - duty + 1.0, 1.0), self.phase_inc);
naive + blep1 - blep2
```

**Triangle** (`oscillator.rs:160-167`): Generated by integrating a PolyBLEP-corrected square wave through a leaky integrator. This approach produces a triangle with better anti-aliasing than the naive piecewise-linear formula, because the integration inherently smooths the corrected square wave's remaining discontinuities:

```rust
let blep_square = square
    + poly_blep(phase, self.phase_inc)
    - poly_blep(rem_euclid_f32(phase + 0.5, 1.0), self.phase_inc);
self.prev_output = 0.999 * self.prev_output + blep_square * self.phase_inc * 4.0;
```

The `0.999` coefficient creates a leaky integrator that prevents DC drift while preserving the triangle shape. The factor `self.phase_inc * 4.0` scales the integration to maintain correct amplitude.

### Phase Modulation for FM Synthesis

The oscillator supports FM synthesis through phase modulation (`oscillator.rs:133-141`). The modulator's output (in radians) is converted to normalized phase and added to the carrier's phase:

```rust
let mod_phase = phase_mod / (2.0 * PI);
let modulated_phase = rem_euclid_f32(self.phase + mod_phase, 1.0);
```

The `rem_euclid_f32` function ensures the modulated phase wraps correctly into [0, 1), using a `no_std`-compatible Euclidean remainder.

---

## Oversampling for Nonlinear Processing

**Source:** `crates/sonido-core/src/oversample.rs`

### Why Oversampling

Nonlinear operations (distortion, waveshaping, saturation) generate new harmonic content. If a 5 kHz input is processed through a waveshaper at 48 kHz, the generated harmonics at 10 kHz, 15 kHz, 20 kHz, and 25 kHz would place the 25 kHz component above Nyquist, causing it to alias back to 23 kHz.

Oversampling solves this by temporarily increasing the sample rate before nonlinear processing:

1. **Upsample** the input signal by factor N (insert samples via interpolation)
2. **Process** through the nonlinear effect at the higher rate (harmonics now have more headroom before Nyquist)
3. **Downsample** with an anti-aliasing filter to remove content above the original Nyquist, then decimate back to the original rate

### Implementation: `Oversampled<const FACTOR: usize, E: Effect>`

Sonido uses const generics to make the oversampling factor a compile-time parameter, enabling the compiler to optimize loops and eliminate branching.

**Upsampling** (`oversample.rs:107-113`) uses linear interpolation between the previous and current input sample:

```rust
fn upsample(&mut self, input: f32) {
    let step = 1.0 / FACTOR as f32;
    for i in 0..FACTOR {
        let t = (i as f32 + 1.0) * step;
        self.work_buffer[i] = self.prev_sample + t * (input - self.prev_sample);
    }
    self.prev_sample = input;
}
```

Linear interpolation is chosen for upsampling because the subsequent anti-aliasing filter in the downsampling stage handles spectral image rejection. Higher-order interpolation at this stage would add CPU cost with diminishing returns.

**Downsampling** (`oversample.rs:116-132`) applies a 16-tap FIR anti-aliasing filter followed by decimation. The filter runs on every upsampled sample, but only the final filtered value (at the decimation point) is output:

```rust
fn downsample(&mut self) -> f32 {
    // ...
    for i in 0..FACTOR {
        // Shift delay line
        // On last sample, compute filtered output
        if i == FACTOR - 1 {
            for (j, &coeff) in coeffs.iter().enumerate() {
                output += self.downsample_state[j] * coeff;
            }
        }
    }
    output
}
```

### Filter Coefficients

Three sets of windowed-sinc FIR coefficients are provided for 2x, 4x, and 8x oversampling. The cutoff frequencies are set to 0.4, 0.2, and 0.1 of the oversampled Nyquist respectively, providing adequate stopband rejection while preserving the passband.

The 2x filter (`COEFFS_2X`) has a notable structure: alternate coefficients are zero. This is characteristic of a half-band filter, an efficient design where roughly half the multiply-accumulate operations can be skipped.

### Latency

The `Oversampled` wrapper reports its latency as the FIR filter's group delay plus the inner effect's latency (`oversample.rs:152-156`):

```rust
fn latency_samples(&self) -> usize {
    let filter_latency = FILTER_ORDER / 2;  // Symmetric FIR group delay
    filter_latency + self.effect.latency_samples()
}
```

For the 16-tap filter (order 15), this adds 7 samples of latency.

---

## Digital Filters

### Biquad (Second-Order IIR)

**Source:** `crates/sonido-core/src/biquad.rs`

The biquad is the workhorse of audio DSP. It implements a second-order IIR (Infinite Impulse Response) filter using the Direct Form I difference equation:

```
y[n] = b0*x[n] + b1*x[n-1] + b2*x[n-2] - a1*y[n-1] - a2*y[n-2]
```

This requires only 5 multiplies and 4 additions per sample, plus 4 values of state (the delay lines `x[n-1]`, `x[n-2]`, `y[n-1]`, `y[n-2]`).

**Direct Form I vs. Direct Form II:** Sonido uses Direct Form I (`biquad.rs:88-101`), which maintains separate input and output delay lines. While Direct Form II is more memory-efficient (2 state variables instead of 4), Direct Form I has better numerical behavior with 32-bit floats because the intermediate values have smaller dynamic range.

### RBJ Audio EQ Cookbook

Coefficient calculation functions implement Robert Bristow-Johnson's Audio EQ Cookbook formulas, the standard reference for biquad filter design in audio. Sonido provides:

- **Lowpass** (`biquad.rs:111-126`): Attenuates frequencies above the cutoff
- **Highpass** (`biquad.rs:138-153`): Attenuates frequencies below the cutoff
- **Bandpass** (`biquad.rs:166-181`): Passes a band around the center frequency
- **Notch** (`biquad.rs:194-209`): Rejects a narrow band at the center frequency
- **Peaking EQ** (`biquad.rs:224-245`): Boosts or cuts around a center frequency

All functions share the same structure: compute the intermediate variables `omega`, `cos(omega)`, `sin(omega)`, and `alpha = sin(omega) / (2*Q)`, then derive the six coefficients. The `Q` parameter controls the filter's bandwidth or resonance.

The coefficient normalization (`biquad.rs:80-86`) divides all coefficients by `a0`, which is standard practice so the difference equation can omit the `a0` multiplication at runtime:

```rust
let a0_inv = 1.0 / a0;
self.b0 = b0 * a0_inv;
// ...
```

### State Variable Filter (SVF)

**Source:** `crates/sonido-core/src/svf.rs`

The SVF offers a different topology that simultaneously provides lowpass, highpass, bandpass, and notch outputs from a single processing step. Sonido implements the Chamberlin SVF with trapezoidal integration for improved stability.

**Why SVF over Biquad?** Two reasons:

1. **Modulation stability**: The SVF can have its cutoff frequency modulated at audio rate without the instability that biquad coefficient changes can cause. This makes it ideal for filter sweeps, envelope-following, and LFO modulation.

2. **Multi-output**: A single SVF computation yields all four filter types simultaneously via `process_all()` (`svf.rs:105-119`), useful when an effect needs multiple filter responses from the same signal.

The coefficient computation (`svf.rs:99-102`) uses `tan(pi * fc / fs)` for the frequency warping, which gives better frequency accuracy near Nyquist compared to the bilinear transform approximation:

```rust
self.g = tanf(PI * self.cutoff / self.sample_rate);
self.k = 1.0 / self.resonance;
```

The core processing (`svf.rs:105-119`) uses implicit trapezoidal integration:

```rust
let v3 = input - self.ic2eq;
let v1 = (self.g * v3 + self.ic1eq) / (1.0 + self.g * (self.g + self.k));
let v2 = self.ic2eq + self.g * v1;
self.ic1eq = 2.0 * v1 - self.ic1eq;
self.ic2eq = 2.0 * v2 - self.ic2eq;
```

The state variables `ic1eq` and `ic2eq` use the "2x trick" for trapezoidal integration: `new_state = 2*output - old_state`. This is equivalent to the standard TPT (topology-preserving transform) formulation by Vadim Zavalishin.

### One-Pole Filters

One-pole lowpass filters appear throughout Sonido as building blocks:

- **Comb filter damping** (`comb.rs:77-78`): A one-pole lowpass in the comb feedback path simulates frequency-dependent absorption in acoustic spaces. Higher frequencies decay faster, as they do in real rooms.
- **Distortion tone control**: A one-pole lowpass after waveshaping tames harsh high-frequency content.
- **Parameter smoothing** (`param.rs`): Exponential smoothing is implemented as a one-pole lowpass.
- **Envelope following**: Level detection uses one-pole filters for attack and release ballistics.

The one-pole lowpass difference equation is:

```
y[n] = y[n-1] + alpha * (x[n] - y[n-1])
```

where `alpha = 1 - exp(-1 / (tau * fs))` and `tau` is the time constant in seconds.

---

## Delay Lines and Interpolation

**Source:** `crates/sonido-core/src/delay.rs`

### Circular Buffers

Both `InterpolatedDelay` and `FixedDelayLine` use circular (ring) buffers. A write pointer advances through the buffer; reading at an offset from the write pointer produces the delayed signal. The modular arithmetic `(write_pos + 1) % buffer.len()` handles the wrap-around.

### Fractional Delay and Interpolation

Many effects require non-integer delay times. A chorus with a 15.7-sample delay, or a comb filter tuned to a specific frequency, cannot use integer-only delays. Interpolation reconstructs values between samples.

**Linear interpolation** (`delay.rs:107-127`): Blends two adjacent samples proportionally to the fractional part:

```
output = buffer[n] + frac * (buffer[n-1] - buffer[n])
```

This is computationally cheap (one multiply, two additions) and adequate for most delay effects.

**Cubic interpolation** (`delay.rs:224-242`): Uses four adjacent samples for a smoother reconstruction. The `FixedDelayLine` implementation provides this option:

```rust
let a0 = y3 - y2 - y0 + y1;
let a1 = y0 - y1 - a0;
let a2 = y2 - y0;
let a3 = y1;
a0 * t3 + a1 * t2 + a2 * t + a3
```

Cubic interpolation reduces the high-frequency roll-off inherent in linear interpolation, which matters for modulated delays (chorus, flanger) where the delay time continuously changes.

### Two Implementations

| | `InterpolatedDelay` | `FixedDelayLine<N>` |
|---|---|---|
| Memory | Heap-allocated (`Vec<f32>`) | Stack-allocated (`[f32; N]`) |
| Size | Runtime-determined | Compile-time constant |
| Use case | General effects | Embedded / `no_std` targets |
| Interpolation | Linear only | None, Linear, or Cubic |

---

## Reverb: Freeverb Topology

**Source:** `crates/sonido-effects/src/reverb.rs`, `crates/sonido-core/src/comb.rs`, `crates/sonido-core/src/allpass.rs`

### Algorithm Structure

Sonido's reverb implements the Freeverb algorithm, itself derived from Manfred Schroeder's 1962 reverb structure. The signal flow is:

```
Input -> Pre-delay -> 8 Parallel Comb Filters -> Sum -> 4 Series Allpass Filters -> Output
```

### Comb Filters: Generating the Reverb Tail

Each comb filter (`comb.rs`) is a delay line with feedback. The output is the delayed signal, which is fed back through a one-pole lowpass (damping) into the delay input:

```
output = delay_line[end]
filterstore = output * (1 - damp) + filterstore * damp
delay_line.write(input + filterstore * feedback)
```

The damping filter in the feedback path is the key to natural-sounding reverb decay: high frequencies are absorbed more rapidly, mimicking the behavior of real acoustic spaces where air absorption and wall materials attenuate treble.

**Delay time tuning**: The 8 comb filter delay lengths at 44.1 kHz are:

```rust
const COMB_TUNINGS_44K: [usize; 8] = [1116, 1188, 1277, 1356, 1422, 1491, 1557, 1617];
```

These values are chosen to be mutually coprime (no common factors), which prevents the comb filters from reinforcing at common delay multiples. If the delay times shared factors, the reverb would exhibit metallic coloration at those frequencies.

For other sample rates, these are scaled proportionally (`reverb.rs:38-40`):

```rust
fn scale_to_rate(samples: usize, target_rate: f32) -> usize {
    (roundf(samples as f32 * target_rate / REFERENCE_RATE) as usize).max(1)
}
```

### Allpass Filters: Diffusion

The allpass filters (`allpass.rs`) smear the comb filter output in time without coloring the frequency response. The Schroeder allpass structure:

```
output = -input + delayed
delay_input = input + delayed * feedback
```

This passes all frequencies at equal amplitude (hence "allpass") but modifies the phase, effectively dispersing energy in time. The 4 series allpass filters progressively increase the echo density, converting the discrete echoes from the comb filters into a smooth, diffuse reverb tail.

### True Stereo Implementation

The reverb uses separate filter tanks for left and right channels (`reverb.rs:104-106`). The right channel has slightly offset delay times:

```rust
const COMB_TUNINGS_44K_R: [usize; 8] = [1139, 1211, 1300, 1379, 1445, 1514, 1580, 1640];
```

This offset (approximately 23 samples at 44.1 kHz, or ~0.5 ms) creates decorrelation between the channels, producing a spatial stereo image. The `stereo_width` parameter (exposed via `ParameterInfo` at index 5, range 0.0–1.0, default 1.0) controls the blend between correlated (mono) and decorrelated (stereo) output using mid-side processing (`reverb.rs:260-264`):

```rust
let mid = (diffused_l + diffused_r) * 0.5;
let side = (diffused_l - diffused_r) * 0.5;
let wet_l = mid + side * self.stereo_width;
let wet_r = mid - side * self.stereo_width;
```

### Reverb Type Selection

The `reverb_type` parameter (index 6, range 0–2, default 0) selects between Room (0), Hall (1), and Plate (2) presets, each with different default room size, decay, and damping values tuned for the acoustic character.

The default Room preset uses **room_size 0.5** (medium room), providing a natural, versatile starting point that's clearly audible without overwhelming the dry signal.

### Feedback Coefficient Calculation

The feedback amount is derived from `room_size` and `decay` parameters (`reverb.rs:220-223`):

```rust
let scaled_room = 0.28 + room * 0.7;    // Range: 0.28 to 0.98
let feedback = scaled_room + decay * (0.98 - scaled_room);
```

This maps the user-friendly 0-1 parameters to a feedback range that stays below 1.0 (ensuring stability) while providing musically useful control. At maximum settings (`room=1.0, decay=1.0`), feedback reaches 0.98, producing very long reverb tails without instability.

---

## Parameter Smoothing

**Source:** `crates/sonido-core/src/param.rs`

### The Zipper Noise Problem

When a parameter like gain changes abruptly from one sample to the next, the resulting discontinuity in the output waveform produces an audible click or "zipper noise." This is especially noticeable for parameters that multiply the signal directly (gain, pan, mix levels).

### Exponential Smoothing: `SmoothedParam`

Sonido's primary smoothing strategy is a one-pole lowpass filter applied to the parameter value itself (`param.rs:122-126`):

```rust
pub fn advance(&mut self) -> f32 {
    self.current = self.current + self.coeff * (self.target - self.current);
    self.current
}
```

This is mathematically equivalent to:

```
param[n] = (1 - alpha) * param[n-1] + alpha * target
```

where `alpha = 1 - exp(-1 / (tau * fs))` (`param.rs:146-151`):

```rust
let time_constant = self.smoothing_time_ms / 1000.0;
let samples = time_constant * self.sample_rate;
self.coeff = 1.0 - expf(-1.0 / samples);
```

**Properties:**
- After one time constant, the parameter reaches ~63.2% of the way to the target
- After five time constants, it reaches ~99.3% (effectively settled)
- The approach is asymptotic: it never quite reaches the target, but gets close enough to be inaudible

Typical smoothing times: 5-10 ms for gain/pan, 20-50 ms for filter cutoff.

### Linear Smoothing: `LinearSmoothedParam`

For crossfades and situations where a predictable transition time matters, Sonido provides linear smoothing (`param.rs:175-225`). The parameter changes at a constant rate:

```rust
pub fn advance(&mut self) -> f32 {
    if self.samples_remaining > 0 {
        self.current += self.increment;
        self.samples_remaining -= 1;
        if self.samples_remaining == 0 {
            self.current = self.target;  // Snap to exact target
        }
    }
    self.current
}
```

Linear smoothing guarantees the target is reached in exactly the specified time. The final snap to the target value prevents floating-point accumulation error from causing drift.

---

## Waveshaping and Distortion

**Source:** `crates/sonido-effects/src/distortion.rs`

### Signal Flow

```
Input -> Drive (gain) -> Waveshaper -> Tone Filter -> Output Level
```

The drive stage amplifies the input before waveshaping, pushing more of the signal into the nonlinear region. The tone filter (one-pole lowpass) tames harsh harmonics generated by the waveshaper. Output level compensates for the volume change.

Default parameters are tuned for clearly audible but tasteful distortion: **drive 12 dB** (moderate crunch), **tone 4000 Hz** (mid-focused, not harsh), and **level -6 dB** (compensating for the gain increase). These defaults follow the "init to clearly audible" philosophy — hear the effect immediately, then dial to taste.

### Waveshaping Functions

Each waveshaping algorithm has a distinct harmonic character determined by the symmetry of its transfer function:

**Symmetric functions** (soft clip, hard clip): Odd-symmetric functions `f(-x) = -f(x)` produce only odd harmonics (3rd, 5th, 7th...). This gives a "hollow" or "buzzy" quality typical of transistor and op-amp distortion.

**Asymmetric functions**: Functions that are not odd-symmetric produce even harmonics (2nd, 4th, 6th...) in addition to odd ones. Even harmonics are perceived as "warm" and "musical," characteristic of vacuum tube distortion.

**Foldback distortion**: When the input exceeds a threshold, the signal folds back rather than clipping. This produces a rich, complex harmonic spectrum with both even and odd harmonics. The wavefolder behavior creates more harmonics as drive increases, rather than just compressing the signal as a clipper does.

### Oversampling Integration

Distortion is a prime candidate for the `Oversampled<N, E>` wrapper since waveshaping inherently generates harmonics that can alias. At 4x oversampling, the 25 kHz alias from a 5 kHz fundamental is pushed to 167 kHz (well above the 96 kHz oversampled Nyquist), preventing audible aliasing artifacts.

---

## Dynamics Processing

**Source:** `crates/sonido-effects/src/compressor.rs`

### Feed-Forward Compressor

The compressor follows a feed-forward topology:

```
Input -> Level Detection -> Gain Computer -> Gain Application -> Output
```

In a feed-forward design, the gain reduction is computed from the input signal level, not the output. This provides more predictable behavior compared to feedback compressor topologies.

### Gain Computation: Soft Knee

The gain computer uses a soft-knee characteristic (`compressor.rs` `GainComputer`) with three regions:

1. **Below knee**: No compression (1:1 ratio), output equals input
2. **Within knee**: Gradual transition, compression increases smoothly
3. **Above knee**: Full compression at the specified ratio

The default threshold is **-18 dB**, which engages on most program material without heavy compression. The knee width (default **6 dB**) is exposed as a configurable parameter (`knee_db`, index 5), allowing users to dial between hard-knee (0 dB) and very soft transitions.

The soft knee prevents the abrupt transition at the threshold that a hard-knee compressor exhibits, producing more transparent compression.

### Ballistics: Attack and Release

The envelope follower uses separate one-pole filters for attack (level increasing) and release (level decreasing). This creates the characteristic timing behavior:

- **Attack time**: How quickly the compressor responds to transients
- **Release time**: How quickly compression releases after the signal drops

Fast attack catches transients but can sound "squashed." Slow attack lets transients through, preserving dynamics at the cost of slower response.

---

## Modulation Effects

### LFO Architecture

**Source:** `crates/sonido-core/src/lfo.rs`

LFOs use phase accumulation: a phase variable increments by `frequency / sample_rate` each sample and wraps at 1.0. The phase is then mapped to a waveform value. This approach is computationally efficient and alias-free for sub-audio frequencies.

### ModulationSource Trait

**Source:** `crates/sonido-core/src/modulation.rs`

The `ModulationSource` trait unifies LFOs, envelope followers, and any other time-varying signal under a common interface:

```rust
pub trait ModulationSource {
    fn mod_advance(&mut self) -> f32;
    fn is_bipolar(&self) -> bool;
    fn mod_reset(&mut self);
    fn mod_value(&self) -> f32;
}
```

Default methods provide bipolar-to-unipolar and unipolar-to-bipolar conversions:
- Bipolar [-1, 1] to unipolar [0, 1]: `(value + 1) * 0.5`
- Unipolar [0, 1] to bipolar [-1, 1]: `value * 2 - 1`

This allows effects to accept any modulation source interchangeably without caring about the source's native range.

### Chorus, Flanger, Phaser

These effects all use an LFO to modulate a delay line or filter parameter:

- **Chorus**: LFO modulates a ~10-30 ms delay time, creating a detuned copy that mixes with the original
- **Flanger**: LFO modulates a shorter delay (~1-10 ms) with feedback, creating the characteristic comb-filter sweep
- **Phaser**: LFO modulates the frequencies of a series of allpass filters, creating notches that sweep through the spectrum

---

## Tempo Synchronization

**Source:** `crates/sonido-core/src/tempo.rs`

### NoteDivision

Musical note values are represented as an enum with a `beats()` method that returns the duration in quarter-note beats:

| Division | Beats | At 120 BPM |
|----------|-------|------------|
| Whole | 4.0 | 2000 ms |
| Half | 2.0 | 1000 ms |
| Quarter | 1.0 | 500 ms |
| DottedEighth | 0.75 | 375 ms |
| Eighth | 0.5 | 250 ms |
| TripletEighth | 1/3 | 166.7 ms |
| Sixteenth | 0.25 | 125 ms |

Conversion to Hz, milliseconds, or samples is provided:

```rust
pub fn to_hz(&self, bpm: f32) -> f32 {
    let beats_per_second = bpm / 60.0;
    beats_per_second / self.beats()
}
```

### TempoManager

The `TempoManager` tracks musical position using a sample counter and provides:

- **Beat/bar position**: Current position in the musical timeline
- **Phase**: Fractional position within the current beat or bar (useful for syncing LFOs)
- **Division conversion**: Convert note divisions to Hz, ms, or samples at the current tempo

Transport control (`play`, `stop`, `reset`) gates the position counter, ensuring effects stay synchronized when playback stops and resumes.

---

## Denormal Protection

**Source:** `crates/sonido-core/src/math.rs` (`flush_denormal`), `crates/sonido-core/src/dc_blocker.rs`

### The Subnormal Problem

IEEE 754 floating-point numbers have a special category called **subnormal** (or **denormalized**) numbers. These are values between zero and the smallest normal float (~1.175e-38 for f32). While mathematically valid, processing subnormals incurs a severe CPU penalty on most architectures -- up to 100x slower than normal float operations on x86 and ARM. This happens because subnormals cannot be handled by the hardware fast path and must be processed in microcode.

In audio DSP, subnormals arise naturally in feedback loops: comb filters, allpass filters, delay lines with feedback, and IIR filters all produce decaying signals that eventually enter the subnormal range. Without mitigation, a reverb tail fading to silence can cause the CPU to spike dramatically.

### Flush Strategy: `flush_denormal()`

Sonido uses an explicit value-threshold flush function:

```rust
#[inline(always)]
pub fn flush_denormal(x: f32) -> f32 {
    if x.abs() < 1e-20 { 0.0 } else { x }
}
```

The threshold of 1e-20 is well above the IEEE 754 subnormal range (~1.2e-38) but far below any audible signal level. This provides a comfortable margin: values below 1e-20 are inaudible (at -400 dBFS) and serve no purpose other than to eventually decay into the problematic subnormal range.

### Where flush_denormal Is Applied

1. **Comb filter feedback** (`comb.rs`): The `filterstore` variable in the one-pole damping filter is flushed each sample, preventing the feedback path from sustaining subnormal values indefinitely.
2. **Biquad output state** (`biquad.rs`): The output delay line `y[n-1]` is flushed, as IIR filters with poles near the unit circle can produce slowly-decaying subnormals.
3. **Oversampler state** (`oversample.rs`): FIR delay lines are flushed to prevent subnormal accumulation in the anti-aliasing filter.

### DC Blocker: `DcBlocker`

**Source:** `crates/sonido-core/src/dc_blocker.rs`

The DC blocker is a first-order highpass filter based on Julius O. Smith's design. Its transfer function is:

```
H(z) = (1 - z^-1) / (1 - R * z^-1)
```

where R is a coefficient close to 1.0 (default ~0.9991 at 48 kHz, giving a cutoff of ~7 Hz). The DC blocker removes any DC offset that accumulates through nonlinear processing, feedback loops, or asymmetric waveshaping. It is particularly useful after:

- Asymmetric distortion (which generates even harmonics and introduces DC)
- Feedback loops that can accumulate DC through integration
- Compressor makeup gain that can shift the baseline

Reference: Julius O. Smith, "Introduction to Digital Filters with Audio Applications"

### Alternatives Not Chosen

- **FTZ/DAZ CPU flags**: Setting the Flush-To-Zero and Denormals-Are-Zero flags on x86 (MXCSR register) or ARM (FPSCR register) would globally flush subnormals at the hardware level. This was not chosen because: (a) it requires platform-specific code, (b) it affects all floating-point operations in the thread, not just audio, (c) it is unavailable in `no_std` environments without inline assembly, and (d) it may interfere with other libraries running in the same thread.
- **DC offset injection**: Adding a tiny DC offset (~1e-15) to feedback signals prevents values from reaching zero and entering the subnormal range. This was not chosen because it introduces actual DC into the signal path, which can accumulate through cascaded effects and cause headroom issues.

---

## Numerical Considerations

### `no_std` Math

Sonido uses `libm` for all transcendental math functions (`sinf`, `cosf`, `tanf`, `expf`, `powf`, `log10f`, etc.) instead of the standard library's `f32` methods. This enables compilation on embedded targets without an FPU or standard library, at the cost of slightly different rounding behavior compared to hardware FPU implementations.

### Fixed-Point Alternatives

The `FixedDelayLine<const N: usize>` uses const generics for stack allocation, avoiding all heap allocation. This is critical for embedded targets like the Daisy Seed (STM32H750, 480 MHz ARM Cortex-M7) where dynamic allocation is either unavailable or has unpredictable latency.

### DC Stability

Several mechanisms prevent DC offset accumulation:

1. **Leaky integrators**: The triangle oscillator uses `0.999` instead of `1.0` as the integrator coefficient, ensuring any DC accumulation decays away
2. **Allpass structure**: The Schroeder allpass (`output = -input + delayed`) naturally cancels DC content
3. **Feedback clamping**: Comb filter feedback is clamped below 1.0 (maximum 0.99), ensuring energy always decays

### Float Precision

Sonido uses `f32` exclusively. For audio at 48 kHz, 32-bit float provides approximately 24 bits of mantissa precision (144 dB dynamic range), which exceeds the requirements of 24-bit audio converters. Double precision (`f64`) would provide no audible benefit while doubling memory bandwidth and reducing cache efficiency.
