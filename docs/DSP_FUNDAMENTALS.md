# DSP Fundamentals in Sonido

This document explains the digital signal processing theory behind Sonido's implementations. Each section connects mathematical concepts to specific source code, showing how textbook DSP translates into production Rust.

## Table of Contents

- [Sampling Theory and Aliasing](#sampling-theory-and-aliasing)
- [Anti-Aliased Oscillators: PolyBLEP](#anti-aliased-oscillators-polyblep)
- [Oversampling for Nonlinear Processing](#oversampling-for-nonlinear-processing)
- [Digital Filters](#digital-filters)
  - [Biquad (Second-Order IIR)](#biquad-second-order-iir)
  - [State Variable Filter (SVF)](#state-variable-filter-svf)
  - [One-Pole Filters](#one-pole-filters)
- [Delay Lines and Interpolation](#delay-lines-and-interpolation)
- [Reverb: Freeverb Topology](#reverb-freeverb-topology)
- [Parameter Smoothing](#parameter-smoothing)
- [Waveshaping and Distortion](#waveshaping-and-distortion)
- [Dynamics Processing](#dynamics-processing)
- [Modulation Effects](#modulation-effects)
- [Tempo Synchronization](#tempo-synchronization)
- [Gain Staging](#gain-staging)
- [Shared DSP Vocabulary](#shared-dsp-vocabulary)
- [Denormal Protection](#denormal-protection)
- [Numerical Considerations](#numerical-considerations)

---

## Sampling Theory and Aliasing

The Nyquist-Shannon theorem states that a continuous signal can be perfectly reconstructed from discrete samples only if the signal contains no frequency components above half the sample rate (the Nyquist frequency). At 48 kHz, this limit is 24 kHz.

**Aliasing** occurs when frequencies above Nyquist are present in a signal. Instead of being rejected, they fold back into the audible range as inharmonic artifacts. This is especially problematic for:

1. **Oscillators** generating non-sinusoidal waveforms (saw, square, pulse) whose Fourier series contain infinite harmonics
2. **Nonlinear processing** (distortion, waveshaping) that creates new harmonics from the input signal

Sonido addresses both cases: PolyBLEP for oscillators and oversampling for nonlinear effects.

---

## Anti-Aliased Oscillators: PolyBLEP

**Source:** `crates/sonido-synth/src/oscillator.rs`

### The Problem with Naive Waveforms

A naive digital sawtooth wave is defined as:

```
saw(t) = 2t - 1,  t in [0, 1)
```

This has an instantaneous discontinuity at `t = 0` where the value jumps from +1 to -1. In the frequency domain, this discontinuity produces harmonics at every integer multiple of the fundamental frequency, extending to infinity. Since a digital system cannot represent frequencies above Nyquist, these harmonics alias back, producing audible artifacts especially at higher pitches.

### The PolyBLEP Solution

PolyBLEP (Polynomial Band-Limited Step) applies a polynomial correction in a small region around each discontinuity. Rather than computing a true band-limited waveform (expensive), PolyBLEP approximates one by smoothing only the transition region.

The correction function in Sonido (`oscillator.rs:183-195`):

```rust
fn poly_blep(t: f32, dt: f32) -> f32 {
    if t < dt {
        // Just past discontinuity
        let t = t / dt;
        2.0 * t - t * t - 1.0
    } else if t > 1.0 - dt {
        // Just before discontinuity
        let t = (t - 1.0) / dt;
        t * t + 2.0 * t + 1.0
    } else {
        0.0
    }
}
```

The parameter `dt` is the phase increment per sample (`frequency / sample_rate`). This defines the width of the correction window. The key insight: the correction window scales with frequency. At higher frequencies (larger `dt`), the correction spans more of the waveform, providing stronger anti-aliasing exactly where it is needed most.

### Waveform Generation

**Sawtooth** (`oscillator.rs:153-157`): The naive sawtooth minus the PolyBLEP correction at phase 0:

```rust
let naive = 2.0 * phase - 1.0;
naive - poly_blep(phase, self.phase_inc)
```

**Square/Pulse** (`oscillator.rs:169-180`): Two PolyBLEP corrections, one at the rising edge (phase 0) and one at the falling edge (phase = duty cycle):

```rust
let naive = if phase < duty { 1.0 } else { -1.0 };
let blep1 = poly_blep(phase, self.phase_inc);
let blep2 = poly_blep(rem_euclid_f32(phase - duty + 1.0, 1.0), self.phase_inc);
naive + blep1 - blep2
```

**Triangle** (`oscillator.rs:160-167`): Generated by integrating a PolyBLEP-corrected square wave through a leaky integrator. This approach produces a triangle with better anti-aliasing than the naive piecewise-linear formula, because the integration inherently smooths the corrected square wave's remaining discontinuities:

```rust
let blep_square = square
    + poly_blep(phase, self.phase_inc)
    - poly_blep(rem_euclid_f32(phase + 0.5, 1.0), self.phase_inc);
self.prev_output = 0.999 * self.prev_output + blep_square * self.phase_inc * 4.0;
```

The `0.999` coefficient creates a leaky integrator that prevents DC drift while preserving the triangle shape. The factor `self.phase_inc * 4.0` scales the integration to maintain correct amplitude.

### Phase Modulation for FM Synthesis

The oscillator supports FM synthesis through phase modulation (`oscillator.rs:133-141`). The modulator's output (in radians) is converted to normalized phase and added to the carrier's phase:

```rust
let mod_phase = phase_mod / (2.0 * PI);
let modulated_phase = rem_euclid_f32(self.phase + mod_phase, 1.0);
```

The `rem_euclid_f32` function ensures the modulated phase wraps correctly into [0, 1), using a `no_std`-compatible Euclidean remainder.

---

## Oversampling for Nonlinear Processing

**Source:** `crates/sonido-core/src/oversample.rs`

### Why Oversampling

Nonlinear operations (distortion, waveshaping, saturation) generate new harmonic content. If a 5 kHz input is processed through a waveshaper at 48 kHz, the generated harmonics at 10 kHz, 15 kHz, 20 kHz, and 25 kHz would place the 25 kHz component above Nyquist, causing it to alias back to 23 kHz.

Oversampling solves this by temporarily increasing the sample rate before nonlinear processing:

1. **Upsample** the input signal by factor N (insert samples via interpolation)
2. **Process** through the nonlinear effect at the higher rate (harmonics now have more headroom before Nyquist)
3. **Downsample** with an anti-aliasing filter to remove content above the original Nyquist, then decimate back to the original rate

### Implementation: `Oversampled<const FACTOR: usize, E: Effect>`

Sonido uses const generics to make the oversampling factor a compile-time parameter, enabling the compiler to optimize loops and eliminate branching.

**Upsampling** uses polyphase windowed-sinc interpolation with a Blackman-Harris window. An 8-sample input history is maintained as a circular buffer. For each output sub-sample, the corresponding polyphase kernel row is convolved with the input history:

```rust
fn upsample(&mut self, input: f32) {
    // Push new sample into circular history
    self.input_history[self.history_pos] = input;
    self.history_pos = (self.history_pos + 1) % UPSAMPLE_TAPS;

    let kernel = self.get_upsample_kernel();
    for p in 0..FACTOR {
        let mut sum = 0.0;
        for t in 0..UPSAMPLE_TAPS {
            let idx = (self.history_pos + t) % UPSAMPLE_TAPS;
            sum += self.input_history[idx] * kernel[p][t];
        }
        self.work_buffer[p] = sum * FACTOR as f32;
    }
}
```

The polyphase decomposition avoids zero-stuffing: instead of inserting zeros and running a full-rate filter, each sub-sample evaluates only the sinc kernel taps that correspond to its fractional offset. The Blackman-Harris window provides >92 dB sidelobe suppression, ensuring interpolation images are well below the noise floor.

This replaces the earlier linear interpolation approach, which suffered from HF rolloff proportional to `sinc(pi*f/fs)^2` — significant at high audio frequencies, especially with 2x oversampling where the image frequencies are close to the passband.

**Downsampling** applies a 48-tap Kaiser-windowed sinc FIR anti-aliasing filter followed by decimation. All upsampled/processed samples are pushed through the FIR delay line, but the convolution sum is only computed at the decimation point:

```rust
fn downsample(&mut self) -> f32 {
    let coeffs = self.get_coefficients();
    for i in 0..FACTOR {
        // Shift delay line
        // On last sample (decimation point), compute filtered output
        if i == FACTOR - 1 {
            for (j, &coeff) in coeffs.iter().enumerate() {
                output += self.downsample_state[j] * coeff;
            }
        }
    }
    output
}
```

### Filter Design

**Downsampling FIR (48-tap, Kaiser-windowed sinc, beta = 8.0):**

Three sets of coefficients are provided for 2x, 4x, and 8x oversampling. The cutoff frequencies are:

| Factor | Normalized Cutoff | Stopband Attenuation |
|--------|------------------|---------------------|
| 2x | 0.45 x oversampled Nyquist | >80 dB |
| 4x | 0.225 x oversampled Nyquist | >80 dB |
| 8x | 0.1125 x oversampled Nyquist | >80 dB |

The Kaiser window beta of 8.0 was chosen to achieve >80 dB stopband attenuation with 48 taps. The relationship between beta and attenuation follows Kaiser's empirical formula: `A = 2.285*(M-1)*pi*df + 7.95` where A is the stopband attenuation in dB. At beta=8.0 with M=48, the achieved attenuation exceeds the 80 dB target across all three coefficient sets. All coefficient sets are symmetric (linear phase), preserving waveform shape through the oversampling path.

**Upsampling kernels (Blackman-Harris windowed sinc, 8 taps/phase):**

Each kernel is a `[FACTOR][8]` array of polyphase sub-filters. The sinc function is centered between taps 3 and 4 (fractional center), and each phase evaluates at a different fractional offset. The last phase in each kernel is the identity (integer sample position). Each row is normalized to sum to `1/FACTOR`; the upsample function multiplies by FACTOR to restore unity DC gain.

### Latency

The `Oversampled` wrapper reports its latency as the sum of FIR group delay, sinc interpolation delay, and the inner effect's latency:

```rust
fn latency_samples(&self) -> usize {
    let filter_latency = FILTER_ORDER / 2;   // 47/2 = 23 samples (symmetric FIR)
    let upsample_latency = UPSAMPLE_TAPS / 2; // 8/2 = 4 samples (sinc kernel)
    filter_latency + upsample_latency + self.effect.latency_samples()
}
```

For the 48-tap downsample filter and 8-tap upsample kernel, this adds 27 samples of latency.

### References

- A.V. Oppenheim & R.W. Schafer, "Discrete-Time Signal Processing", Ch. 4 & 7 (multirate signal processing)
- J.F. Kaiser, "Nonrecursive Digital Filter Design Using the I0-sinh Window", Proc. IEEE Int. Symp. Circuits & Systems, 1974 (Kaiser window design)
- F.J. Harris, "On the Use of Windows for Harmonic Analysis with the DFT", Proc. IEEE, 1978 (Blackman-Harris window)

---

## Digital Filters

### Biquad (Second-Order IIR)

**Source:** `crates/sonido-core/src/biquad.rs`

The biquad is the workhorse of audio DSP. It implements a second-order IIR (Infinite Impulse Response) filter using the Direct Form I difference equation:

```
y[n] = b0*x[n] + b1*x[n-1] + b2*x[n-2] - a1*y[n-1] - a2*y[n-2]
```

This requires only 5 multiplies and 4 additions per sample, plus 4 values of state (the delay lines `x[n-1]`, `x[n-2]`, `y[n-1]`, `y[n-2]`).

**Direct Form I vs. Direct Form II:** Sonido uses Direct Form I (`biquad.rs:88-101`), which maintains separate input and output delay lines. While Direct Form II is more memory-efficient (2 state variables instead of 4), Direct Form I has better numerical behavior with 32-bit floats because the intermediate values have smaller dynamic range.

### RBJ Audio EQ Cookbook

Coefficient calculation functions implement Robert Bristow-Johnson's Audio EQ Cookbook formulas, the standard reference for biquad filter design in audio. Sonido provides:

- **Lowpass** (`biquad.rs:111-126`): Attenuates frequencies above the cutoff
- **Highpass** (`biquad.rs:138-153`): Attenuates frequencies below the cutoff
- **Bandpass** (`biquad.rs:166-181`): Passes a band around the center frequency
- **Notch** (`biquad.rs:194-209`): Rejects a narrow band at the center frequency
- **Peaking EQ** (`biquad.rs:224-245`): Boosts or cuts around a center frequency

All functions share the same structure: compute the intermediate variables `omega`, `cos(omega)`, `sin(omega)`, and `alpha = sin(omega) / (2*Q)`, then derive the six coefficients. The `Q` parameter controls the filter's bandwidth or resonance.

The coefficient normalization (`biquad.rs:80-86`) divides all coefficients by `a0`, which is standard practice so the difference equation can omit the `a0` multiplication at runtime:

```rust
let a0_inv = 1.0 / a0;
self.b0 = b0 * a0_inv;
// ...
```

### State Variable Filter (SVF)

**Source:** `crates/sonido-core/src/svf.rs`

The SVF offers a different topology that simultaneously provides lowpass, highpass, bandpass, and notch outputs from a single processing step. Sonido implements the Chamberlin SVF with trapezoidal integration for improved stability.

**Why SVF over Biquad?** Two reasons:

1. **Modulation stability**: The SVF can have its cutoff frequency modulated at audio rate without the instability that biquad coefficient changes can cause. This makes it ideal for filter sweeps, envelope-following, and LFO modulation.

2. **Multi-output**: A single SVF computation yields all four filter types simultaneously via `process_all()` (`svf.rs:105-119`), useful when an effect needs multiple filter responses from the same signal.

The coefficient computation (`svf.rs:99-102`) uses `tan(pi * fc / fs)` for the frequency warping, which gives better frequency accuracy near Nyquist compared to the bilinear transform approximation:

```rust
self.g = tanf(PI * self.cutoff / self.sample_rate);
self.k = 1.0 / self.resonance;
```

The core processing (`svf.rs:105-119`) uses implicit trapezoidal integration:

```rust
let v3 = input - self.ic2eq;
let v1 = (self.g * v3 + self.ic1eq) / (1.0 + self.g * (self.g + self.k));
let v2 = self.ic2eq + self.g * v1;
self.ic1eq = 2.0 * v1 - self.ic1eq;
self.ic2eq = 2.0 * v2 - self.ic2eq;
```

The state variables `ic1eq` and `ic2eq` use the "2x trick" for trapezoidal integration: `new_state = 2*output - old_state`. This is equivalent to the standard TPT (topology-preserving transform) formulation by Vadim Zavalishin.

### One-Pole Filters

One-pole lowpass filters appear throughout Sonido as building blocks:

- **Comb filter damping** (`comb.rs:77-78`): A one-pole lowpass in the comb feedback path simulates frequency-dependent absorption in acoustic spaces. Higher frequencies decay faster, as they do in real rooms.
- **Distortion tone control**: A one-pole lowpass after waveshaping tames harsh high-frequency content.
- **Parameter smoothing** (`param.rs`): Exponential smoothing is implemented as a one-pole lowpass.
- **Envelope following**: Level detection uses one-pole filters for attack and release ballistics.

The one-pole lowpass difference equation is:

```
y[n] = y[n-1] + alpha * (x[n] - y[n-1])
```

where `alpha = 1 - exp(-1 / (tau * fs))` and `tau` is the time constant in seconds.

---

## Delay Lines and Interpolation

**Source:** `crates/sonido-core/src/delay.rs`

### Circular Buffers

Both `InterpolatedDelay` and `FixedDelayLine` use circular (ring) buffers. A write pointer advances through the buffer; reading at an offset from the write pointer produces the delayed signal. The modular arithmetic `(write_pos + 1) % buffer.len()` handles the wrap-around.

### Fractional Delay and Interpolation

Many effects require non-integer delay times. A chorus with a 15.7-sample delay, or a comb filter tuned to a specific frequency, cannot use integer-only delays. Interpolation reconstructs values between samples.

**Linear interpolation** (`delay.rs:107-127`): Blends two adjacent samples proportionally to the fractional part:

```
output = buffer[n] + frac * (buffer[n-1] - buffer[n])
```

This is computationally cheap (one multiply, two additions) and adequate for most delay effects.

**Cubic interpolation** (Lagrange 3rd-order): Uses four adjacent samples for a smoother reconstruction. Both `InterpolatedDelay` and `FixedDelayLine` support this via `set_interpolation(Interpolation::Cubic)`:

```rust
let a0 = y3 - y2 - y0 + y1;
let a1 = y0 - y1 - a0;
let a2 = y2 - y0;
let a3 = y1;
a0 * t3 + a1 * t2 + a2 * t + a3
```

Cubic interpolation reduces the high-frequency roll-off inherent in linear interpolation, which matters for modulated delays (chorus, flanger) where the delay time continuously changes.

### Two Implementations

| | `InterpolatedDelay` | `FixedDelayLine<N>` |
|---|---|---|
| Memory | Heap-allocated (`Vec<f32>`) | Stack-allocated (`[f32; N]`) |
| Size | Runtime-determined | Compile-time constant |
| Use case | General effects | Embedded / `no_std` targets |
| Interpolation | None, Linear, or Cubic (default: Linear) | None, Linear, or Cubic |

---

## Reverb: Freeverb Topology

**Source:** `crates/sonido-effects/src/reverb.rs`, `crates/sonido-core/src/comb.rs`, `crates/sonido-core/src/allpass.rs`

### Algorithm Structure

Sonido's reverb implements the Freeverb algorithm, itself derived from Manfred Schroeder's 1962 reverb structure. The signal flow is:

```
Input -> Pre-delay -> 8 Parallel Comb Filters -> Sum -> 4 Series Allpass Filters -> Output
```

### Comb Filters: Generating the Reverb Tail

Each comb filter (`comb.rs`) is a delay line with feedback. The output is the delayed signal, which is fed back through a one-pole lowpass (damping) into the delay input:

```
output = delay_line[end]
filterstore = output * (1 - damp) + filterstore * damp
delay_line.write(input + filterstore * feedback)
```

The damping filter in the feedback path is the key to natural-sounding reverb decay: high frequencies are absorbed more rapidly, mimicking the behavior of real acoustic spaces where air absorption and wall materials attenuate treble.

**Delay time tuning**: The 8 comb filter delay lengths at 44.1 kHz are:

```rust
const COMB_TUNINGS_44K: [usize; 8] = [1116, 1188, 1277, 1356, 1422, 1491, 1557, 1617];
```

These values are chosen to be mutually coprime (no common factors), which prevents the comb filters from reinforcing at common delay multiples. If the delay times shared factors, the reverb would exhibit metallic coloration at those frequencies.

For other sample rates, these are scaled proportionally (`reverb.rs:38-40`):

```rust
fn scale_to_rate(samples: usize, target_rate: f32) -> usize {
    (roundf(samples as f32 * target_rate / REFERENCE_RATE) as usize).max(1)
}
```

### Allpass Filters: Diffusion

The allpass filters (`allpass.rs`) smear the comb filter output in time without coloring the frequency response. The Schroeder allpass structure:

```
output = -input + delayed
delay_input = input + delayed * feedback
```

This passes all frequencies at equal amplitude (hence "allpass") but modifies the phase, effectively dispersing energy in time. The 4 series allpass filters progressively increase the echo density, converting the discrete echoes from the comb filters into a smooth, diffuse reverb tail.

### True Stereo Implementation

The reverb uses separate filter tanks for left and right channels (`reverb.rs:104-106`). The right channel has slightly offset delay times:

```rust
const COMB_TUNINGS_44K_R: [usize; 8] = [1139, 1211, 1300, 1379, 1445, 1514, 1580, 1640];
```

This offset (approximately 23 samples at 44.1 kHz, or ~0.5 ms) creates decorrelation between the channels, producing a spatial stereo image. The `stereo_width` parameter (exposed via `ParameterInfo` at index 5, range 0.0–1.0, default 1.0) controls the blend between correlated (mono) and decorrelated (stereo) output using mid-side processing (`reverb.rs:260-264`):

```rust
let mid = (diffused_l + diffused_r) * 0.5;
let side = (diffused_l - diffused_r) * 0.5;
let wet_l = mid + side * self.stereo_width;
let wet_r = mid - side * self.stereo_width;
```

### Reverb Type Selection

The `reverb_type` parameter (index 6, range 0–2, default 0) selects between Room (0), Hall (1), and Plate (2) presets, each with different default room size, decay, and damping values tuned for the acoustic character.

The default Room preset uses **room_size 0.5** (medium room), providing a natural, versatile starting point that's clearly audible without overwhelming the dry signal.

### Feedback Coefficient Calculation

The feedback amount is derived from `room_size` and `decay` parameters (`reverb.rs:220-223`):

```rust
let scaled_room = 0.28 + room * 0.7;    // Range: 0.28 to 0.98
let feedback = scaled_room + decay * (0.98 - scaled_room);
```

This maps the user-friendly 0-1 parameters to a feedback range that stays below 1.0 (ensuring stability) while providing musically useful control. At maximum settings (`room=1.0, decay=1.0`), feedback reaches 0.98, producing very long reverb tails without instability.

### Feedback Resonance Compensation

A feedback comb filter with coefficient `g` has peak gain `1/(1-g)` at resonance frequencies (where the round-trip delay produces constructive interference). At `g=0.5`, peak gain is 2× (+6 dB); at `g=0.9`, peak gain is 10× (+20 dB). Without compensation, the wet signal at resonance exceeds the dry signal for any `g > 0`, violating the -1 dBFS peak ceiling.

**Exact compensation: `c = (1-g)`**

Scaling the wet signal by `(1-g)` exactly cancels peak-gain amplification:

```
output_at_resonance = c × 1/(1-g) = (1-g)/(1-g) = 1.0
```

The compensated wet signal at resonance equals the dry signal — a perfect crossfade with zero amplification at any mix setting. This is implemented in `gain::feedback_wet_compensation()` and used by delay, flanger, and phaser.

| Feedback | Compensation | Peak wet at resonance |
|----------|-------------|----------------------|
| 0.0 | 1.000 | 1.0 |
| 0.4 (delay default) | 0.600 | 1.0 |
| 0.5 (flanger/phaser default) | 0.500 | 1.0 |
| 0.9 | 0.100 | 1.0 |
| 0.95 | 0.050 | 1.0 |

At low feedback (g=0.1), compensation is 0.9 — barely any attenuation. At high feedback (g=0.9), compensation is 0.1 — the wet signal is quieter but the decay tail is correspondingly longer. The `output` parameter provides makeup gain if needed.

**Moderate compensation for parallel banks: `c = sqrt(1-g)`**

Reverb uses 8 parallel comb filters averaged (÷8 = −18 dB headroom). At any frequency, only 1–2 combs resonate simultaneously (the mutually-prime delay lengths prevent coincident resonance). The effective gain is far less than the theoretical per-comb peak, so exact `(1-g)` compensation is unnecessarily aggressive — it would attenuate the wet signal by ~7 dB more than needed at typical hall settings.

The reverb uses `sqrt(1-g)` inline: the geometric mean of unity and exact compensation. This sits between no attenuation and full cancellation, matching the reverb's parallel-averaging topology.

**Topology distinction:**

| Topology | Peak gain | Compensation | Effects |
|----------|-----------|-------------|---------|
| Single comb (delay, flanger) | `1/(1-g)` | `(1-g)` exact | Delay, Flanger |
| Allpass cascade (phaser) | Unity magnitude | `(1-g)` conservative | Phaser |
| Parallel comb bank (reverb) | `~1/(8(1-g))` | `sqrt(1-g)` moderate | Reverb |

The phaser's allpass cascade has unity magnitude at all frequencies — resonance is narrowband (3 notch-peak pairs vs hundreds of comb teeth). Exact compensation is conservative but harmless, keeping the phaser well within ceiling.

**Industry context:** Static wet-signal compensation is the standard approach for embedded/pedal DSP (FV-1, EQD Afterneath). DAW-grade reverbs (MAX/MSP gen~, Valhalla) sometimes use dynamic AGC, but the per-sample envelope tracking is too expensive for Sonido's embedded targets (Daisy Seed, Hothouse).

Reference: CCRMA PASP, "Feedback Comb Filters" — peak gain = 1/(1-|g|).

Source: `crates/sonido-core/src/gain.rs` (`feedback_wet_compensation`), `crates/sonido-effects/src/reverb.rs` (`update_comb_params`)

---

## Parameter Smoothing

**Source:** `crates/sonido-core/src/param.rs`

### The Zipper Noise Problem

When a parameter like gain changes abruptly from one sample to the next, the resulting discontinuity in the output waveform produces an audible click or "zipper noise." This is especially noticeable for parameters that multiply the signal directly (gain, pan, mix levels).

### Exponential Smoothing: `SmoothedParam`

Sonido's primary smoothing strategy is a one-pole lowpass filter applied to the parameter value itself (`param.rs:122-126`):

```rust
pub fn advance(&mut self) -> f32 {
    self.current = self.current + self.coeff * (self.target - self.current);
    self.current
}
```

This is mathematically equivalent to:

```
param[n] = (1 - alpha) * param[n-1] + alpha * target
```

where `alpha = 1 - exp(-1 / (tau * fs))` (`param.rs:146-151`):

```rust
let time_constant = self.smoothing_time_ms / 1000.0;
let samples = time_constant * self.sample_rate;
self.coeff = 1.0 - expf(-1.0 / samples);
```

**Properties:**
- After one time constant, the parameter reaches ~63.2% of the way to the target
- After five time constants, it reaches ~99.3% (effectively settled)
- The approach is asymptotic: it never quite reaches the target, but gets close enough to be inaudible

Typical smoothing times: 5-10 ms for gain/pan, 20-50 ms for filter cutoff.

### Linear Smoothing: `LinearSmoothedParam`

For crossfades and situations where a predictable transition time matters, Sonido provides linear smoothing (`param.rs:175-225`). The parameter changes at a constant rate:

```rust
pub fn advance(&mut self) -> f32 {
    if self.samples_remaining > 0 {
        self.current += self.increment;
        self.samples_remaining -= 1;
        if self.samples_remaining == 0 {
            self.current = self.target;  // Snap to exact target
        }
    }
    self.current
}
```

Linear smoothing guarantees the target is reached in exactly the specified time. The final snap to the target value prevents floating-point accumulation error from causing drift.

---

## Waveshaping and Distortion

**Source:** `crates/sonido-effects/src/distortion.rs`

### Signal Flow

```
Input -> Drive (gain) -> Waveshaper -> Tone Filter -> Output Level
```

The drive stage amplifies the input before waveshaping, pushing more of the signal into the nonlinear region. The tone filter (one-pole lowpass) tames harsh harmonics generated by the waveshaper. Output level compensates for the volume change.

Default parameters are tuned for clearly audible but tasteful distortion: **drive 12 dB** (moderate crunch), **tone 4000 Hz** (mid-focused, not harsh), and **level -6 dB** (compensating for the gain increase). These defaults follow the "init to clearly audible" philosophy — hear the effect immediately, then dial to taste.

### Waveshaping Functions

Each waveshaping algorithm has a distinct harmonic character determined by the symmetry of its transfer function:

**Symmetric functions** (soft clip, hard clip): Odd-symmetric functions `f(-x) = -f(x)` produce only odd harmonics (3rd, 5th, 7th...). This gives a "hollow" or "buzzy" quality typical of transistor and op-amp distortion.

**Asymmetric functions**: Functions that are not odd-symmetric produce even harmonics (2nd, 4th, 6th...) in addition to odd ones. Even harmonics are perceived as "warm" and "musical," characteristic of vacuum tube distortion.

**Foldback distortion**: When the input exceeds a threshold, the signal folds back rather than clipping. This produces a rich, complex harmonic spectrum with both even and odd harmonics. The wavefolder behavior creates more harmonics as drive increases, rather than just compressing the signal as a clipper does. Implementation uses a bounded iterative loop (16 max iterations) rather than recursion, ensuring safety on embedded targets with limited stack (e.g., Daisy Seed).

### Oversampling Integration

Distortion is a prime candidate for the `Oversampled<N, E>` wrapper since waveshaping inherently generates harmonics that can alias. At 4x oversampling, the 25 kHz alias from a 5 kHz fundamental is pushed to 167 kHz (well above the 96 kHz oversampled Nyquist), preventing audible aliasing artifacts.

---

## Dynamics Processing

**Source:** `crates/sonido-effects/src/compressor.rs`

### Feed-Forward Compressor

The compressor follows a feed-forward topology:

```
Input -> Level Detection -> Gain Computer -> Gain Application -> Output
```

In a feed-forward design, the gain reduction is computed from the input signal level, not the output. This provides more predictable behavior compared to feedback compressor topologies.

### Gain Computation: Soft Knee

The gain computer uses a soft-knee characteristic (`compressor.rs` `GainComputer`) with three regions:

1. **Below knee**: No compression (1:1 ratio), output equals input
2. **Within knee**: Gradual transition, compression increases smoothly
3. **Above knee**: Full compression at the specified ratio

The default threshold is **-18 dB**, which engages on most program material without heavy compression. The knee width (default **6 dB**) is exposed as a configurable parameter (`knee_db`, index 5), allowing users to dial between hard-knee (0 dB) and very soft transitions.

The soft knee prevents the abrupt transition at the threshold that a hard-knee compressor exhibits, producing more transparent compression.

### Ballistics: Attack and Release

The envelope follower uses separate one-pole filters for attack (level increasing) and release (level decreasing). This creates the characteristic timing behavior:

- **Attack time**: How quickly the compressor responds to transients
- **Release time**: How quickly compression releases after the signal drops

Fast attack catches transients but can sound "squashed." Slow attack lets transients through, preserving dynamics at the cost of slower response.

---

## Modulation Effects

### LFO Architecture

**Source:** `crates/sonido-core/src/lfo.rs`

LFOs use phase accumulation: a phase variable increments by `frequency / sample_rate` each sample and wraps at 1.0. The phase is then mapped to a waveform value. This approach is computationally efficient and alias-free for sub-audio frequencies.

### ModulationSource Trait

**Source:** `crates/sonido-core/src/modulation.rs`

The `ModulationSource` trait unifies autonomous generators (LFOs, ADSR envelopes, audio-rate modulators) under a common interface. `EnvelopeFollower` does not implement this trait — it requires audio input via `process()` and is not autonomous:

```rust
pub trait ModulationSource {
    fn mod_advance(&mut self) -> f32;
    fn is_bipolar(&self) -> bool;
    fn mod_reset(&mut self);
    fn mod_value(&self) -> f32;
}
```

Default methods provide bipolar-to-unipolar and unipolar-to-bipolar conversions:
- Bipolar [-1, 1] to unipolar [0, 1]: `(value + 1) * 0.5`
- Unipolar [0, 1] to bipolar [-1, 1]: `value * 2 - 1`

This allows effects to accept any modulation source interchangeably without caring about the source's native range.

### Chorus, Flanger, Phaser

These effects all use an LFO to modulate a delay line or filter parameter:

- **Chorus**: LFO modulates a ~10-30 ms delay time, creating a detuned copy that mixes with the original
- **Flanger**: LFO modulates a shorter delay (~1-10 ms) with feedback, creating the characteristic comb-filter sweep
- **Phaser**: LFO modulates the frequencies of a series of allpass filters, creating notches that sweep through the spectrum

---

## Tempo Synchronization

**Source:** `crates/sonido-core/src/tempo.rs`

### NoteDivision

Musical note values are represented as an enum with a `beats()` method that returns the duration in quarter-note beats:

| Division | Beats | At 120 BPM |
|----------|-------|------------|
| Whole | 4.0 | 2000 ms |
| Half | 2.0 | 1000 ms |
| Quarter | 1.0 | 500 ms |
| DottedEighth | 0.75 | 375 ms |
| Eighth | 0.5 | 250 ms |
| TripletEighth | 1/3 | 166.7 ms |
| Sixteenth | 0.25 | 125 ms |

Conversion to Hz, milliseconds, or samples is provided:

```rust
pub fn to_hz(&self, bpm: f32) -> f32 {
    let beats_per_second = bpm / 60.0;
    beats_per_second / self.beats()
}
```

### TempoManager

The `TempoManager` tracks musical position using a sample counter and provides:

- **Beat/bar position**: Current position in the musical timeline
- **Phase**: Fractional position within the current beat or bar (useful for syncing LFOs)
- **Division conversion**: Convert note divisions to Hz, ms, or samples at the current tempo

Transport control (`play`, `stop`, `reset`) gates the position counter, ensuring effects stay synchronized when playback stops and resumes.

---

## Gain Staging

**Source:** `crates/sonido-core/src/gain.rs`

### The Problem

Nonlinear effects (distortion, saturation, wah) generate gain that depends on the input signal and parameter settings. Without explicit output level control, effects can produce unexpectedly hot output that clips downstream processors. At the same time, effects with inherent gain reduction (compressor, gate) need makeup gain to restore levels.

### Universal Output Level

All effects in Sonido expose an `output` parameter (last index in `ParameterInfo`) that provides ±20 dB of post-processing level control. The output level is applied as a linear gain multiplier at the end of the processing chain, after all DSP but before the final output.

The `gain.rs` module provides the shared implementation (`gain.rs:1-30`):

```rust
pub fn output_level_param(sample_rate: f32) -> SmoothedParam {
    SmoothedParam::standard(1.0, sample_rate)  // 0 dB, 10ms smoothing
}

pub fn set_output_level_db(param: &mut SmoothedParam, db: f32) {
    param.set_target(db_to_linear(db.clamp(OUTPUT_MIN_DB, OUTPUT_MAX_DB)));
}
```

The output level is stored internally as linear gain (1.0 = 0 dB) for efficient per-sample multiplication, with dB conversion only at the parameter interface boundary.

### Per-Effect Gain Staging

| Effect | Net Gain at Defaults | Output Default | Strategy |
|--------|---------------------|----------------|----------|
| Distortion | +3.7 dB (signal-dependent) | -6.0 dB | Drive compensated by output level |
| TapeSaturation | ~0 dB | -6.0 dB | Drive compensated by output level |
| Wah | ~0 dB | 0.0 dB | BP normalized by Q (see below) |
| Compressor | -4.5 dB | makeup 0 dB | Safety-first (user adds makeup) |
| All others | ~0 dB | 0.0 dB | Unity gain at defaults |

### Wah Bandpass Normalization

The SVF bandpass filter has peak gain equal to Q at the center frequency (`svf.rs:99`: `k = 1/Q`). With the default Q=5, the raw bandpass output would be 5x the input level (+14 dB). Rather than compensating with an output level trim (a band-aid), the implementation normalizes the transfer function directly (`wah.rs:202`):

```rust
let normalized = filtered / resonance;  // Unity peak gain at any Q
let out = normalized * 0.8 + input * 0.2;  // 80/20 wet/dry blend for body
```

At the center frequency: `(input * Q) / Q * 0.8 + input * 0.2 = input`. Unity. The normalization is algebraically exact regardless of Q.

### Shared Dry/Wet Mix

**Source:** `crates/sonido-core/src/math.rs`

The dry/wet mix pattern appears in nearly every effect. Rather than inlining `input * (1.0 - mix) + wet * mix` (which appears ~22 times across the codebase), all effects use the shared `wet_dry_mix()` helper:

```rust
pub fn wet_dry_mix(dry: f32, wet: f32, mix: f32) -> f32 {
    dry + (wet - dry) * mix  // one fewer multiply than the expanded form
}
```

The `wet_dry_mix_stereo()` variant applies the same crossfade to both channels. These helpers are semantically identical to the inline form but eliminate duplication and make the mix operation self-documenting.

---

## Shared DSP Vocabulary

**Source:** `crates/sonido-core/src/gain.rs`, `param.rs`, `param_info.rs`, `one_pole.rs`, `math.rs`

Sonido extracts recurring DSP patterns into a shared vocabulary in `sonido-core`. This eliminates copy-paste duplication across the 15 effects while establishing consistent conventions.

### SmoothedParam Presets

Rather than scattering magic numbers (`10.0`, `5.0`, `20.0`, `50.0`) across constructors, effects use named presets with documented semantics:

| Preset | Time | Use Case |
|--------|------|----------|
| `SmoothedParam::fast()` | 5 ms | Drive, nonlinear gain — needs fast response |
| `SmoothedParam::standard()` | 10 ms | Most params (rate, depth, mix, level) |
| `SmoothedParam::slow()` | 20 ms | Filter coefficients, EQ, reverb decay |
| `SmoothedParam::interpolated()` | 50 ms | Delay time, predelay (avoids pitch artifacts) |

### ParamDescriptor Factories

Common parameter descriptors are constructed via factory methods rather than inline struct literals:

- `ParamDescriptor::mix()` — 0-100%, default 50%
- `ParamDescriptor::depth()` — 0-100%, default 50%
- `ParamDescriptor::feedback()` — 0-95%, default 50%
- `ParamDescriptor::time_ms(name, short, min, max, default)` — custom time param
- `ParamDescriptor::gain_db(name, short, min, max, default)` — custom gain param

### OnePole Filter

**Source:** `crates/sonido-core/src/one_pole.rs`

A minimal one-pole (6 dB/octave) lowpass filter used for tone controls and HF rolloff. Replaces ad-hoc inline implementations in distortion and tape saturation with a shared struct:

```rust
let mut tone = OnePole::new(48000.0, 4000.0);
let filtered = tone.process(input);  // one-pole lowpass at 4 kHz
```

The coefficient `exp(-2*pi*freq/sample_rate)` gives the standard one-pole response with -3 dB at the specified frequency.

---

## Fast Math Approximations

Sonido provides fast mathematical approximations for targets without
hardware transcendental support (Cortex-M7, etc.). These trade full
IEEE 754 precision for predictable cycle counts.

### Function Summary

| Function | Replaces | Use Case | Max Error |
|----------|----------|----------|-----------|
| `fast_log2(x)` | `libm::logf` / log2 | dB conversion, dynamics | < 0.2% relative |
| `fast_exp2(x)` | `libm::expf` / exp2 | dB conversion, dynamics | < 0.2% relative |
| `fast_db_to_linear(db)` | `db_to_linear()` | Gain, level metering | < 0.05 dB |
| `fast_linear_to_db(lin)` | `linear_to_db()` | Gain, level metering | < 0.05 dB |
| `fast_sin_turns(turns)` | `libm::sinf` | LFO modulation | < 0.001 absolute |
| `fast_tan(x)` | `libm::tanf` | Filter coefficients | < 0.1% (f < sr/4) |

### Implementation Techniques

- **`fast_log2` / `fast_exp2`**: IEEE 754 float bit decomposition (Remez minimax polynomial). ~10-15 Cortex-M7 cycles vs ~150-200 for libm equivalents.
- **`fast_sin_turns`**: Bhaskara I parabolic approximation. Input in turns (0.0-1.0 = full cycle). ~16 cycles vs ~100+ for sinf.
- **`fast_tan`**: Padé [2/1] rational approximation. Accurate for filter coefficient computation below sr/4. ~12 cycles.
- **`fast_db_to_linear` / `fast_linear_to_db`**: Composed from fast_exp2/fast_log2 with dB scaling.

### When to Use

Use fast_math functions in **hot DSP loops on embedded targets** (Cortex-M7) where transcendental calls dominate cycle budget. The error margins are inaudible for all documented use cases (LFO modulation, dynamics, filter coefficients). For offline processing or non-embedded targets, prefer the standard `libm` functions.

Currently used by: LFO, Compressor, Gate, ParametricEq, Phaser (see ADR-020).

### References

- ARM Cortex-M7 Technical Reference Manual (FPU instruction timings)
- Remez exchange algorithm (minimax polynomial fitting)
- Bhaskara I's sine approximation (7th century, parabolic form)
- Padé approximants for rational function approximation

**Implementation:** `crates/sonido-core/src/fast_math.rs`

---

## Denormal Protection

**Source:** `crates/sonido-core/src/math.rs` (`flush_denormal`), `crates/sonido-core/src/dc_blocker.rs`

### The Subnormal Problem

IEEE 754 floating-point numbers have a special category called **subnormal** (or **denormalized**) numbers. These are values between zero and the smallest normal float (~1.175e-38 for f32). While mathematically valid, processing subnormals incurs a severe CPU penalty on most architectures -- up to 100x slower than normal float operations on x86 and ARM. This happens because subnormals cannot be handled by the hardware fast path and must be processed in microcode.

In audio DSP, subnormals arise naturally in feedback loops: comb filters, allpass filters, delay lines with feedback, and IIR filters all produce decaying signals that eventually enter the subnormal range. Without mitigation, a reverb tail fading to silence can cause the CPU to spike dramatically.

### Flush Strategy: `flush_denormal()`

Sonido uses an explicit value-threshold flush function:

```rust
#[inline(always)]
pub fn flush_denormal(x: f32) -> f32 {
    if x.abs() < 1e-20 { 0.0 } else { x }
}
```

The threshold of 1e-20 is well above the IEEE 754 subnormal range (~1.2e-38) but far below any audible signal level. This provides a comfortable margin: values below 1e-20 are inaudible (at -400 dBFS) and serve no purpose other than to eventually decay into the problematic subnormal range.

### Where flush_denormal Is Applied

1. **Comb filter feedback** (`comb.rs`): The `filterstore` variable in the one-pole damping filter is flushed each sample, preventing the feedback path from sustaining subnormal values indefinitely.
2. **Biquad output state** (`biquad.rs`): The output delay line `y[n-1]` is flushed, as IIR filters with poles near the unit circle can produce slowly-decaying subnormals.
3. **Oversampler state** (`oversample.rs`): FIR delay lines are flushed to prevent subnormal accumulation in the anti-aliasing filter.

### DC Blocker: `DcBlocker`

**Source:** `crates/sonido-core/src/dc_blocker.rs`

The DC blocker is a first-order highpass filter based on Julius O. Smith's design. Its transfer function is:

```
H(z) = (1 - z^-1) / (1 - R * z^-1)
```

where R is a coefficient close to 1.0 (default ~0.9991 at 48 kHz, giving a cutoff of ~7 Hz). The DC blocker removes any DC offset that accumulates through nonlinear processing, feedback loops, or asymmetric waveshaping. It is particularly useful after:

- Asymmetric distortion (which generates even harmonics and introduces DC)
- Feedback loops that can accumulate DC through integration
- Compressor makeup gain that can shift the baseline

Reference: Julius O. Smith, "Introduction to Digital Filters with Audio Applications"

### Alternatives Not Chosen

- **FTZ/DAZ CPU flags**: Setting the Flush-To-Zero and Denormals-Are-Zero flags on x86 (MXCSR register) or ARM (FPSCR register) would globally flush subnormals at the hardware level. This was not chosen because: (a) it requires platform-specific code, (b) it affects all floating-point operations in the thread, not just audio, (c) it is unavailable in `no_std` environments without inline assembly, and (d) it may interfere with other libraries running in the same thread.
- **DC offset injection**: Adding a tiny DC offset (~1e-15) to feedback signals prevents values from reaching zero and entering the subnormal range. This was not chosen because it introduces actual DC into the signal path, which can accumulate through cascaded effects and cause headroom issues.

---

## Numerical Considerations

### `no_std` Math

Sonido uses `libm` for all transcendental math functions (`sinf`, `cosf`, `tanf`, `expf`, `powf`, `log10f`, etc.) instead of the standard library's `f32` methods. This enables compilation on embedded targets without an FPU or standard library, at the cost of slightly different rounding behavior compared to hardware FPU implementations.

### Fixed-Point Alternatives

The `FixedDelayLine<const N: usize>` uses const generics for stack allocation, avoiding all heap allocation. This is critical for embedded targets like the Daisy Seed (STM32H750, 480 MHz ARM Cortex-M7) where dynamic allocation is either unavailable or has unpredictable latency.

### DC Stability

Several mechanisms prevent DC offset accumulation:

1. **Leaky integrators**: The triangle oscillator uses `0.999` instead of `1.0` as the integrator coefficient, ensuring any DC accumulation decays away
2. **Allpass structure**: The Schroeder allpass (`output = -input + delayed`) naturally cancels DC content
3. **Feedback clamping**: Comb filter feedback is clamped below 1.0 (maximum 0.99), ensuring energy always decays

### Float Precision

Sonido uses `f32` exclusively. For audio at 48 kHz, 32-bit float provides approximately 24 bits of mantissa precision (144 dB dynamic range), which exceeds the requirements of 24-bit audio converters. Double precision (`f64`) would provide no audible benefit while doubling memory bandwidth and reducing cache efficiency.
